1. cf. assets folder for screenshots (100% coverage reached)
2. In this problem, the pre-condition is given by the first constraint. This requires n to be a positive integer. As documented in the code, I assume positive to mean >0 and hence added the assert statement for n>0. The check for it being an integer is naturally given by the compiler not accepting other data types. The post-condition is similarly given by the constraints and requires allWays to be non-negative, hence the allWays >=0 assert statements. An invariant that has to hold is that none of the values oneStepBefore, twoStepsBefore nor allWays are<0 as they are all intermediary results and can due to the post-condition not take on negative values. This is handled by assert statements in the loop. As the value allWays is set to be the sum and not changed, it wouldn't make sense to assert the sum still being correct. The only state changes happen through the addition and variable swaps.
3. I wrote tests that test "normal" input fulfilling the pre-condition by including values 1,2 for the trivial case (n value is returned) and taking in between known values such as 3, 5 as well. I further checked the last possible value for n which is 45. This is the last one that does not exceed the integer boundary. Additionally, I included tests with non-positive values 0, -2 and Integer.MIN_VALUE. The post-condition is indirectly verified by my expected results being positive integers. The invariant is verified by testing that no assertion was thrown.
4. Due to the asserts for the pre-condition, I excluded non-positive numbers and considered two general properties given by the task description. For trivial input handled by the first if (values 1, 2 for n), I verified by specifying the integer range that the returned value is equal to n. Further, for the case of any other positive integer greater than 2, where the answer is not trivial, I used the general assertion of >0 to make sure that the post-condition is met. Due to jqwik shrinking issues, I had to set the max to 91 for it to not fail when generating inputs that would not be within boundary.